\nonstopmode{}
\documentclass[letterpaper]{book}
\usepackage[times,inconsolata,hyper]{Rd}
\usepackage{makeidx}
\usepackage[utf8,latin1]{inputenc}
% \usepackage{graphicx} % @USE GRAPHICX@
\makeindex{}
\begin{document}
\chapter*{}
\begin{center}
{\textbf{\huge Package `merTools'}}
\par\bigskip{\large \today}
\end{center}
\begin{description}
\raggedright{}
\item[Title]\AsIs{Tools for Analyzing Mixed Effect Regression Models}
\item[Version]\AsIs{0.4.1}
\item[Description]\AsIs{Provides methods for extracting results from mixed-effect model
objects fit with the 'lme4' package. Allows construction of prediction intervals
efficiently from large scale linear and generalized linear mixed-effects models.}
\item[Depends]\AsIs{R (>= 3.0.2), arm, lme4 (>= 1.1-11), methods, dplyr}
\item[Suggests]\AsIs{testthat, knitr, rmarkdown, parallel, rstanarm, Amelia, DAAG,
nlme}
\item[Imports]\AsIs{mvtnorm, DT, shiny, abind, ggplot2, blme, broom, foreach}
\item[License]\AsIs{GPL (>=2)}
\item[LazyData]\AsIs{true}
\item[VignetteBuilder]\AsIs{knitr}
\item[RoxygenNote]\AsIs{6.0.1}
\item[BugReports]\AsIs{}\url{https://www.github.com/jknowles/merTools}\AsIs{}
\item[NeedsCompilation]\AsIs{no}
\item[Author]\AsIs{Jared E. Knowles [aut, cre],
Carl Frederick [aut],
Alex Whitworth [ctb]}
\item[Maintainer]\AsIs{Jared E. Knowles }\email{jknowles@gmail.com}\AsIs{}
\end{description}
\Rdcontents{\R{} topics documented:}
\inputencoding{utf8}
\HeaderA{averageObs}{Find the average observation for a merMod object}{averageObs}
%
\begin{Description}\relax
Extract a data frame of a single row that represents the
average observation in a merMod object. This function also allows the
user to pass a series of conditioning argument to calculate the average
observation conditional on other characteristics.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
averageObs(merMod, varList = NULL, origData = NULL, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{merMod}] a merMod object

\item[\code{varList}] optional, a named list of conditions to subset the data on

\item[\code{origData}] (default=NULL) a data frame containing the original,
untransformed data used to call the model. This MUST be specified if
the original variables used in formula function calls are NOT present
as 'main effects'.

\item[\code{...}] not used currently
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Each character and factor variable in the data.frame is assigned to the
modal category and each numeric variable is collapsed to the mean. Currently if
mode is a tie, returns a "." Uses the collapseFrame function.
\end{Details}
%
\begin{Value}
a data frame with a single row for the average observation, but with full
factor levels. See details for more.
\end{Value}
\inputencoding{utf8}
\HeaderA{collapseFrame}{Collapse a dataframe to a single average row}{collapseFrame}
%
\begin{Description}\relax
Take an entire dataframe and summarize it in one row by using the
mean and mode.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
collapseFrame(data)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{data}] a data.frame
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Each character and factor variable in the data.frame is assigned to the
modal category and each numeric variable is collapsed to the mean. Currently if
mode is a tie, returns a "."
\end{Details}
%
\begin{Value}
a data frame with a single row
\end{Value}
\inputencoding{utf8}
\HeaderA{draw}{Draw a single observation out of an object matching some criteria}{draw}
\methaliasA{draw.merMod}{draw}{draw.merMod}
%
\begin{Description}\relax
Draw is used to select a single observation out of an R object.
Additional parameters allow the user to control how that observation is
chosen in order to manipulate that observation later. This is a generic
function with methods for a number of objects.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
draw(object, type = c("random", "average"), varList = NULL, seed = NULL,
  ...)

## S3 method for class 'merMod'
draw(object, type = c("random", "average"), varList = NULL,
  seed = NULL, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] the object to draw from

\item[\code{type}] what kind of draw to make. Options include random or average

\item[\code{varList}] a list specifying filters to subset the data by when making the
draw

\item[\code{seed}] numeric, optional argument to set seed for simulations, ignored if type="average"

\item[\code{...}] additional arguments required by certain methods
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
In cases of tie, ".", may be substituted for factors.
\end{Details}
%
\begin{Value}
a data.frame with a single row representing the desired observation
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
fm1 <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
# Random case
draw(fm1, type = "random")
# Average
draw(fm1, type = "average")
# Subset
draw(fm1, type = "average", varList = list("Subject" = "308"))

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{expectedRank}{Calculate the expected rank of random coefficients that account for uncertainty.}{expectedRank}
%
\begin{Description}\relax
\code{expectedRank} calculates the expected rank and the percentile expected
rank of any random term in a merMod object.  A simple ranking of the estimated
random effects (as produced by \code{\LinkA{ranef}{ranef}}) is not satisfactory
because it ignores any amount of uncertainty.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
expectedRank(merMod, groupFctr = NULL, term = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{merMod}] An object of class merMod

\item[\code{groupFctr}] An optional character vector specifying the name(s) the grouping factor(s)
over which the random coefficient of interest varies.  This is the
variable to the right of the pipe, \code{|}, in the [g]lmer formula.
This parameter is optional. If none is specified all terms will be returned.

\item[\code{term}] An optional character vector specifying the name(s) of the random coefficient of interest. This is the
variable to the left of the pipe, \code{|}, in the [g]lmer formula. Partial
matching is attempted on the intercept term so the following character
strings will all return rankings based on the intercept (\emph{provided that
they do not match the name of another random coefficient for that factor}):
\code{c("(Intercept)", "Int", "intercep", ...)}.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Inspired by Lingsma et al. (2010, see also Laird and Louis 1989),
expectedRank sums the probability that each level of the grouping factor is
greater than every other level of the grouping factor, similar to a
two-sample t-test.

The formula for the expected rank is:
\deqn{ExpectedRank_i = 1 + \sum \phi((\theta_i - \theta_k) / \sqrt(var(\theta_i)+var(\theta_k))}{}
where \eqn{\phi}{} is the standard normal distribution function, \eqn{\theta}{}
is the estimated random effect and \eqn{var(\theta)}{} is the posterior
variance of the estimated random effect. We add one to the sum so that the
minimum rank is one instead of zero so that in the case where there is no
overlap between the variances of the random effects (or if the variances are
zero), the expected rank equals the actual rank.  The ranks are ordered such
that the winners have ranks that are greater than the losers.

The formula for the percentile expected rank is:
\deqn{100 * (ExpectedRank_i - 0.5) / N_grps}{}
where \eqn{N_grps}{} is the number of grouping factor levels. The percentile
expected rank can be interpreted as the fraction of levels that score at or
below the given level.

NOTE: \code{expectedRank} will only work under conditions that \code{lme4::ranef}
will work. One current example of when this is \emph{not} the case is for
models when there are multiple terms specified per factor (e.g. uncorrelated random
coefficients for the same term, e.g.
\code{lmer(Reaction \textasciitilde{} Days + (1 | Subject) + (0 + Days | Subject), data = sleepstudy)})
\end{Details}
%
\begin{Value}
A data.frame with the following five columns:
\begin{description}

\item[groupFctr] a character representing name of the grouping factor
\item[groupLevel] a character representing the level of the grouping factor
\item[term] a character representing the formula term for the group
\item[estimate] effect estimate from \code{lme4::ranef(, condVar=TRUE)}).
\item[std.error] the posterior variance of the estimate random effect
(from \code{lme4::ranef(, condVar=TRUE)}); named "\code{term}"\_var.
\item[ER] The expected rank.
\item[pctER] The percentile expected rank.

\end{description}

\end{Value}
%
\begin{References}\relax
Laird NM and Louis TA. Empirical Bayes Ranking Methods. \emph{Journal of
Education Statistics}. 1989;14(1)29-46. Available at
\url{http://www.jstor.org/stable/1164724}.


Lingsma HF, Steyerberg EW, Eijkemans MJC, et al. Comparing and
ranking hospitals based on outcome: results from The Netherlands Stroke Survey.
\emph{QJM: An International Journal of Medicine}. 2010;103(2):99-108.
doi:10.1093/qjmed/hcp169
\end{References}
%
\begin{Examples}
\begin{ExampleCode}
#For a one-level random intercept model
require(lme4)
m1 <- lmer(Reaction ~ Days + (1 | Subject), sleepstudy)
(m1.er <- expectedRank(m1))

#For a one-level random intercept model with multiple random terms
require(lme4)
m2 <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
#ranked by the random slope on Days
(m2.er1 <- expectedRank(m2, term="Days"))
#ranked by the random intercept
(m2.er2 <- expectedRank(m2, term="int"))

## Not run: 
#For a two-level model with random intercepts
require(lme4)
m3 <- lmer(y ~ service * dept + (1|s) + (1|d), InstEval)
#Ranked by the random intercept on 's'
(m3.er1 <- expectedRank(m3, groupFctr="s", term="Intercept"))

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{famlink}{Find link function family}{famlink}
%
\begin{Description}\relax
Find link function family
\end{Description}
%
\begin{Usage}
\begin{verbatim}
famlink(object, resp = object@resp)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] a merMod object

\item[\code{resp}] the response vector
\end{ldescription}
\end{Arguments}
%
\begin{Value}
the link function and family
\end{Value}
\inputencoding{utf8}
\HeaderA{fastdisp}{fastdisp: faster display of model summaries}{fastdisp}
\methaliasA{fastdisp.merMod}{fastdisp}{fastdisp.merMod}
\methaliasA{fastdisp.merModList}{fastdisp}{fastdisp.merModList}
%
\begin{Description}\relax
Display model fit summary of x or x like objects, fast
\end{Description}
%
\begin{Usage}
\begin{verbatim}
fastdisp(x, ...)

## S3 method for class 'merMod'
fastdisp(x, ...)

## S3 method for class 'merModList'
fastdisp(x, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] a model object

\item[\code{...}] additional arguments to pass to \code{arm::\LinkA{display}{display}}
including number of digits
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Faster than the implementation in the arm package because it avoids refitting

The time saving is only noticeable for large, time-consuming (g)lmer
fits.
\end{Details}
%
\begin{Value}
A printed summary of a x object
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{display}{display}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
#Compare the time for displaying this modest model
require(arm)
m1 <- lmer(y ~ lectage + studage + (1|d) + (1|s), data=InstEval)
system.time(display(m1))
system.time(fastdisp(m1))

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{FEsim}{Simulate fixed effects from merMod \code{FEsim} simulates fixed effects from merMod object posterior distributions}{FEsim}
%
\begin{Description}\relax
Simulate fixed effects from merMod
\code{FEsim} simulates fixed effects from merMod object posterior distributions
\end{Description}
%
\begin{Usage}
\begin{verbatim}
FEsim(merMod, n.sims = 200, oddsRatio = FALSE, seed = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{merMod}] a merMod object from the lme4 package

\item[\code{n.sims}] number of simulations to use

\item[\code{oddsRatio}] logical, should parameters be converted to odds ratios?

\item[\code{seed}] numeric, optional argument to set seed for simulations
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Use the Gelman sim technique to build fixed effect estimates and
confidence intervals. Uses the sim function in the arm package
\end{Details}
%
\begin{Value}
a data frame with the following columns
\begin{description}

\item[\code{term}] Name of fixed term (intercept/coefficient)
\item[\code{mean}] Mean of the simulations
\item[\code{median}] Median of the simulations
\item[\code{sd}] Standard deviation of the simulations, \code{NA} if \code{oddsRatio=TRUE}

\end{description}

\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
require(lme4)
m2 <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
fe2 <- FEsim(m2, 25)
head(fe2)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{fetch.merMod.msgs}{Extract all warning msgs from a merMod object}{fetch.merMod.msgs}
%
\begin{Description}\relax
Extract all warning msgs from a merMod object
\end{Description}
%
\begin{Usage}
\begin{verbatim}
fetch.merMod.msgs(x)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] a merMod object
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{findFormFuns}{\code{findFormFuns} used by \LinkA{averageObs}{averageObs} to calculate proper averages}{findFormFuns}
%
\begin{Description}\relax
The purpose is to properly derive data for the average observation in the
data by being 'aware' of formulas that contain interactions and/or function
calls. For example, in the old behavior, if the formula contained a square
term specified as \code{I(x\textasciicircum{}2)}, we were returning the mean of x\textasciicircum{}2 not the
square of mean(x).
\end{Description}
%
\begin{Usage}
\begin{verbatim}
findFormFuns(merMod, origData = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{merMod}] the merMod object from which to draw the average observation

\item[\code{origData}] (default=NULL) a data frame containing the original,
untransformed data used to call the model. This MUST be specified if
the original variables used in formula function calls are NOT present
as 'main effects'.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a data frame with a single row for the average observation, but with full
factor levels. See details for more.
\end{Value}
\inputencoding{utf8}
\HeaderA{fixef.merModList}{Extract fixed-effects estimates for a merModList}{fixef.merModList}
%
\begin{Description}\relax
Extract fixed-effects estimates for a merModList
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S3 method for class 'merModList'
fixef(object, add.dropped = FALSE, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] any fitted model object from which fixed
effects estimates can be extracted.

\item[\code{add.dropped}] for models with rank-deficient design
matrix, reconstitute the full-length parameter vector by
adding \code{NA} values in appropriate locations?

\item[\code{...}] optional additional arguments. Currently
none are used in any methods.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Extract the estimates of the fixed-effects parameters from a list of
fitted \code{merMod} models. Takes the mean of the individual \code{fixef}
objects for each of the component models in the \code{merModList}.
\end{Details}
%
\begin{Value}
a named, numeric vector of fixed-effects estimates.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
sim_list <- replicate(n = 10,
        expr = sleepstudy[sample(row.names(sleepstudy), 180),],
        simplify=FALSE)
fml <- "Reaction ~ Days + (Days | Subject)"
mod <- lmerModList(fml, data = sim_list)
fixef(mod)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{hsb}{A subset of data from the 1982 High School and Beyond survey used as examples for HLM software}{hsb}
\keyword{datasets}{hsb}
%
\begin{Description}\relax
A key example dataset used for examples in the HLM software manual.
Included here for use in replicating HLM analyses in R.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
hsb
\end{verbatim}
\end{Usage}
%
\begin{Format}
A data frame with 7,185 observations on the following 8 variables.
\begin{description}

\item[\code{schid}] a numeric vector, 160 unique values
\item[\code{mathach}] a numeric vector for the performance on a standardized math assessment
\item[\code{female}] a numeric vector coded 0 for male and 1 for female
\item[\code{ses}] a numeric measure of student socio-economic status
\item[\code{minority}] a numeric vector coded 0 for white and 1 for non-white students
\item[\code{schtype}] a numeric vector coded 0 for public and 1 for private schools
\item[\code{meanses}] a numeric, the average SES for each school in the data set
\item[\code{size}] a numeric for the number of students in the school

\end{description}
\end{Format}
%
\begin{Details}\relax
The data file used for this presentation is a subsample from the
1982 High School and Beyond Survey and is used extensively in
Hierarchical Linear Models by Raudenbush and Bryk. It consists of 7,185 students
nested in 160 schools.
\end{Details}
%
\begin{Source}\relax
Data made available by UCLA Institute for Digital Research and Education
(IDRE) online: \url{https://stats.idre.ucla.edu/other/hlm/hlm-mlm/introduction-to-multilevel-modeling-using-hlm}
\end{Source}
%
\begin{References}\relax
Stephen W. Raudenbush and Anthony S. Bryk (2002). Hierarchical
Linear Models: Applications and Data Analysis Methods (2nd ed.). SAGE.
\end{References}
%
\begin{Examples}
\begin{ExampleCode}
data(hsb)
head(hsb)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{ICC}{Calculate the intraclass correlation using mixed effect models}{ICC}
%
\begin{Description}\relax
Calculate the intraclass correlation using mixed effect models
\end{Description}
%
\begin{Usage}
\begin{verbatim}
ICC(outcome, group, data, subset = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{outcome}] a character representing the variable of the outcome

\item[\code{group}] a character representing the name of the grouping term

\item[\code{data}] a data.frame

\item[\code{subset}] an optional subset
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a numeric for the intraclass correlation
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
data(sleepstudy)
ICC(outcome = "Reaction", group = "Subject", data = sleepstudy)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{lmerModList}{Apply a multilevel model to a list of data frames}{lmerModList}
\aliasA{bglmerModList}{lmerModList}{bglmerModList}
\aliasA{blmerModList}{lmerModList}{blmerModList}
\aliasA{glmerModList}{lmerModList}{glmerModList}
%
\begin{Description}\relax
Apply a multilevel model to a list of data frames

Apply a Bayesian multilevel model to a list of data frames

Apply a generalized linear multilevel model to a list of data frames

Apply a Bayesian generalized linear multilevel model to a list of data frames
\end{Description}
%
\begin{Usage}
\begin{verbatim}
lmerModList(formula, data, parallel = NULL, ...)

blmerModList(formula, data, parallel = NULL, ...)

glmerModList(formula, data, parallel = NULL, ...)

bglmerModList(formula, data, parallel = NULL, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{formula}] a formula to pass through compatible with merMod

\item[\code{data}] a list object with each element being a data.frame

\item[\code{parallel}] logical, should the models be run in parallel?

\item[\code{...}] additional arguments to pass to the estimating function
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a list of fitted merMod objects of class merModList

a merModList

a merModList

a merModList
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
sim_list <- replicate(n = 10,
        expr = sleepstudy[sample(row.names(sleepstudy), 180),],
        simplify=FALSE)
fml <- "Reaction ~ Days + (Days | Subject)"
mod <- lmerModList(fml, data = sim_list)
summary(mod)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{merTools}{merTools: Provides methods for extracting and exploring results from merMod objects in the lme4 package.}{merTools}
\aliasA{merTools-package}{merTools}{merTools.Rdash.package}
\aliasA{merTools-package}{merTools}{merTools.Rdash.package}
%
\begin{Description}\relax
The merTools package contains convenience tools for extracting useful
information from and exploring the implications of merMod objects created by
the lme4 package.  These convenience functions are especially useful for
merMod objects that take a long time to estimate due to their complexity or
because they are estimated on very large samples.
\end{Description}
%
\begin{Details}\relax
See the vignettes for usage examples
\end{Details}
%
\begin{Section}{merMod extraction/utility functions}


\begin{itemize}

\item \code{\LinkA{fastdisp}{fastdisp}}
\item \code{\LinkA{superFactor}{superFactor}}
\item \code{\LinkA{REextract}{REextract}}
\item \code{\LinkA{REsim}{REsim}}
\item \code{\LinkA{FEsim}{FEsim}}
\item \code{\LinkA{RMSE.merMod}{RMSE.merMod}}
\item \code{\LinkA{thetaExtract}{thetaExtract}}
\item \code{\LinkA{REquantile}{REquantile}}

\end{itemize}

\end{Section}
%
\begin{Section}{merMod exploration functions}


\begin{itemize}

\item \code{\LinkA{plotREsim}{plotREsim}}
\item \code{\LinkA{plotFEsim}{plotFEsim}}
\item \code{\LinkA{draw}{draw}}
\item \code{\LinkA{wiggle}{wiggle}}
\item \code{\LinkA{subBoot}{subBoot}}
\item \code{\LinkA{predictInterval}{predictInterval}}
\item \code{\LinkA{expectedRank}{expectedRank}}
\item \code{\LinkA{REimpact}{REimpact}}
\item \code{\LinkA{shinyMer}{shinyMer}}

\end{itemize}

\end{Section}
\inputencoding{utf8}
\HeaderA{modelFixedEff}{Extract averaged fixed effect parameters across a list of merMod objects}{modelFixedEff}
%
\begin{Description}\relax
Extract averaged fixed effect parameters across a list of merMod objects
\end{Description}
%
\begin{Usage}
\begin{verbatim}
modelFixedEff(modList, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{modList}] an object of class merModList

\item[\code{...}] additional arguments to pass to \code{\LinkA{tidy}{tidy}}
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The Rubin correction for combining estimates and standard errors from
Rubin (1987) is applied to adjust for the within and between imputation variances.
\end{Details}
%
\begin{Value}
a data.frame of the averaged fixed effect parameters
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
sim_list <- replicate(n = 10,
        expr = sleepstudy[sample(row.names(sleepstudy), 180),],
        simplify=FALSE)
fml <- "Reaction ~ Days + (Days | Subject)"
mod <- lmerModList(fml, data = sim_list)
modelFixedEff(mod)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{modelInfo}{Extract model information from a merMod}{modelInfo}
%
\begin{Description}\relax
Extract model information from a merMod
\end{Description}
%
\begin{Usage}
\begin{verbatim}
modelInfo(object)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] a merMod object
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Simple summary information about the object, number
of observations, number of grouping terms, AIC, and residual standard deviation
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
sim_list <- replicate(n = 10,
        expr = sleepstudy[sample(row.names(sleepstudy), 180),],
        simplify=FALSE)
fml <- "Reaction ~ Days + (Days | Subject)"
mod <- lmerModList(fml, data = sim_list)
modelInfo(mod[[1]])
lapply(mod, modelInfo)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{modelRandEffStats}{Extract data.frame of random effect statistics from merMod List}{modelRandEffStats}
%
\begin{Description}\relax
Extract data.frame of random effect statistics from merMod List
\end{Description}
%
\begin{Usage}
\begin{verbatim}
modelRandEffStats(modList)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{modList}] a list of multilevel models
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a data.frame
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
sim_list <- replicate(n = 10,
        expr = sleepstudy[sample(row.names(sleepstudy), 180),],
        simplify=FALSE)
fml <- "Reaction ~ Days + (Days | Subject)"
mod <- lmerModList(fml, data = sim_list)
modelRandEffStats(mod)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{plotFEsim}{Plot the results of a simulation of the fixed effects}{plotFEsim}
%
\begin{Description}\relax
Plot the simulated fixed effects on a ggplot2 chart
\end{Description}
%
\begin{Usage}
\begin{verbatim}
plotFEsim(data, level = 0.95, stat = "median", sd = TRUE,
  intercept = FALSE, sigmaScale = NULL, oddsRatio = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{data}] a data.frame generated by \code{\LinkA{FEsim}{FEsim}} with simulations of
the fixed effects of a \code{\LinkA{merMod}{merMod}}

\item[\code{level}] the width of the confidence interval

\item[\code{stat}] a character value indicating the variable name in data of the
midpoint of the estimated interval, e.g. "mean" or "median"

\item[\code{sd}] logical, indicating whether or not to plot error bars around
the estimates (default is TRUE). Calculates the width of the error bars
based on \code{level} and the variable named "sd" in \code{data}

\item[\code{intercept}] logical, should the intercept be included, default is FALSE

\item[\code{sigmaScale}] a numeric value to divide the estimate and the standard
deviation by in the case of doing an effect size calculation

\item[\code{oddsRatio}] logical, should the parameters be converted to odds ratios
before plotting
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a ggplot2 plot of the coefficient effects
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
 fm1 <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
 (p1 <- plotFEsim(FEsim(fm1)))
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{plotREsim}{Plot the results of a simulation of the random effects}{plotREsim}
%
\begin{Description}\relax
Plot the simulated random effects on a ggplot2 chart. Points that
are distinguishable from zero (i.e. the confidence band based on \code{level}
does not cross the red line) are highlighted. Currently, the plots are ordered
according to the grouping factor.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
plotREsim(data, level = 0.95, stat = "median", sd = TRUE,
  sigmaScale = NULL, oddsRatio = FALSE, labs = FALSE, facet = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{data}] a data.frame generated by \code{\LinkA{REsim}{REsim}} with simulations of
the random effects of a \code{\LinkA{merMod}{merMod}}

\item[\code{level}] the width of the confidence interval

\item[\code{stat}] a character value indicating the variable name in data of the
midpoint of the estimated interval, e.g. "mean" or "median"

\item[\code{sd}] a logical indicating whether or not to plot error bars around
the estimates (default is TRUE). Calculates the width of the error bars
based on \code{level} and the variable named "sd" in \code{data}

\item[\code{sigmaScale}] a numeric value to divide the estimate and the standard
deviation by in the case of doing an effect size calculation

\item[\code{oddsRatio}] logical, should the parameters be converted to odds ratios
before plotting

\item[\code{labs}] logical, include the labels of the groups on the x-axis

\item[\code{facet}] Accepts either logical (\code{TRUE}) or \code{list} to specify which
random effects to plot. If \code{TRUE}, facets by both \code{groupFctr} and \code{term}.
If \code{list} selects the panel specified by the named elements of the list
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a ggplot2 plot of the coefficient effects
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
 fm1 <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
 (p1 <- plotREsim(REsim(fm1)))
 #Plot just the random effects for the Days slope
 (p2 <- plotREsim(REsim(fm1), facet= list(groupFctr= "Subject", term= "Days")))
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{plot\_sim\_error\_chks}{Extract all warning msgs from a merMod object}{plot.Rul.sim.Rul.error.Rul.chks}
%
\begin{Description}\relax
Extract all warning msgs from a merMod object
\end{Description}
%
\begin{Usage}
\begin{verbatim}
plot_sim_error_chks(type = c("FE", "RE"), level = 0.95, stat = c("mean",
  "median"), sd = TRUE, sigmaScale = NULL, oddsRatio = FALSE,
  labs = FALSE, facet = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{type}] check a fixed or random effect

\item[\code{level}] the width of the confidence interval

\item[\code{stat}] a character value indicating the variable name in data of the
midpoint of the estimated interval, e.g. "mean" or "median"

\item[\code{sd}] a logical indicating whether or not to plot error bars around
the estimates (default is TRUE). Calculates the width of the error bars
based on \code{level} and the variable named "sd" in \code{data}

\item[\code{sigmaScale}] a numeric value to divide the estimate and the standard
deviation by in the case of doing an effect size calculation

\item[\code{oddsRatio}] logical, should the parameters be converted to odds ratios
before plotting

\item[\code{labs}] logical, include the labels of the groups on the x-axis

\item[\code{facet}] Accepts either logical (\code{TRUE}) or \code{list} to specify which
random effects to plot. If \code{TRUE}, facets by both \code{groupFctr} and \code{term}.
If \code{list} selects the panel specified by the named elements of the list
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{predictInterval}{Predict from merMod objects with a prediction interval}{predictInterval}
%
\begin{Description}\relax
This function provides a way to capture model uncertainty in
predictions from multi-level models fit with \code{lme4}. By drawing a sampling
distribution for the random and the fixed effects and then estimating the fitted
value across that distribution, it is possible to generate a prediction interval
for fitted values that includes all variation in the model except for variation
in the covariance parameters, theta. This is a much faster alternative than
bootstrapping for models fit to medium to large datasets.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
predictInterval(merMod, newdata, which = c("full", "fixed", "random", "all"),
  level = 0.8, n.sims = 1000, stat = c("median", "mean"),
  type = c("linear.prediction", "probability"), include.resid.var = TRUE,
  returnSims = FALSE, seed = NULL, .parallel = FALSE, .paropts = NULL,
  fix.intercept.variance = FALSE, ignore.fixed.terms = c())
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{merMod}] a merMod object from lme4

\item[\code{newdata}] a data.frame of new data to predict

\item[\code{which}] a character specifying what to return, by default it returns the
full interval, but you can also select to return only the fixed variation or
the random component variation. If full is selected the resulting data.frame
will be \code{nrow(newdata) * number of model levels} long

\item[\code{level}] the width of the prediction interval

\item[\code{n.sims}] number of simulation samples to construct

\item[\code{stat}] take the median or mean of simulated intervals

\item[\code{type}] type of prediction to develop

\item[\code{include.resid.var}] logical, include or exclude the residual variance for
linear models

\item[\code{returnSims}] logical, should all n.sims simulations be returned?

\item[\code{seed}] numeric, optional argument to set seed for simulations

\item[\code{.parallel, }] logical should parallel computation be used, default is FALSE

\item[\code{.paropts, }] -NOT USED: Caused issue \#54- a list of additional options passed into the foreach function
when parallel computation is enabled. This is important if (for example) your
code relies on external data or packages: use the .export and .packages arguments
to supply them so that all cluster nodes have the correct environment set up
for computing.

\item[\code{fix.intercept.variance}] logical; should the variance of the intercept
term be adjusted downwards to roughly correct for its covariance with the
random effects, as if all the random effects are intercept effects?

\item[\code{ignore.fixed.terms}] a numeric or string vector of indexes or names of
fixed effects which should be considered as fully known (zero variance). This
can result in under-conservative intervals, but for models with random effects
nested inside fixed effects, holding the fixed effects constant intervals may
give intervals with closer to nominal coverage than the over-conservative
intervals without this option, which ignore negative correlation between the
outer (fixed) and inner (random) coefficients.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
To generate a prediction interval, the function first computes a simulated
distribution of all of the parameters in the model. For the random, or grouping,
effects, this is done by sampling from a multivariate normal distribution which
is defined by the BLUP estimate provided by \code{ranef} and the associated
variance-covariance matrix for each observed level of each grouping terms. For
each grouping term, an array is build that has as many rows as there are levels
of the grouping factor, as many columns as there are predictors at that level
(e.g. an intercept and slope), and is stacked as high as there are number of
simulations. These arrays are then multiplied by the new data provided to the
function to produce a matrix of yhat values. The result is a matrix of the simulated
values of the linear predictor for each observation for each simulation. Each
grouping term has such a matrix for each observation. These values can be added
to get the estimate of the fitted value for the random effect terms, and this
can then be added to a matrix of simulated values for the fixed effect level to
come up with \code{n.sims} number of possible yhat values for each observation.

The distribution of simulated values is cut according to the interval requested
by the function. The median or mean value as well as the upper and lower bounds
are then returned. These can be presented either on the linear predictor scale
or on the response scale using the link function in the \code{merMod}.
\end{Details}
%
\begin{Value}
a data.frame with three columns:
\begin{description}

\item[\code{fit}] The center of the distribution of predicted values as defined by
the \code{stat} parameter.
\item[\code{lwr}] The lower prediction interval bound corresponding to the quantile cut
defined in \code{level}.
\item[\code{upr}] The upper prediction interval bound corresponding to the quantile cut
defined in \code{level}.

\end{description}

If returnSims = TRUE, then the individual simulations are attached to this
data.frame in the attribute \code{sim.results} and are stored as a matrix.
\end{Value}
%
\begin{Note}\relax
\code{merTools} includes the functions \code{subBoot} and \code{thetaExtract}
to allow the user to estimate the variability in \code{theta} from a larger
model by bootstrapping the model fit on a subset, to allow faster estimation.
\end{Note}
%
\begin{Examples}
\begin{ExampleCode}
m1 <- lmer(Reaction ~ Days + (1 | Subject), sleepstudy)
regFit <- predict(m1, newdata = sleepstudy[11, ]) # a single value is returned
intFit <- predictInterval(m1, newdata = sleepstudy[11, ]) # bounded values
# Can do glmer
d1 <- cbpp
d1$y <- d1$incidence / d1$size
 gm2 <- glmer(y ~ period + (1 | herd), family = binomial, data = d1,
               nAGQ = 9, weights = d1$size)
 regFit <- predict(gm2, newdata = d1[1:10, ])
 # get probabilities
 regFit <- predict(gm2, newdata = d1[1:10, ], type = "response")
 intFit <- predictInterval(gm2, newdata = d1[1:10, ], type = "probability")
 intFit <- predictInterval(gm2, newdata = d1[1:10, ], type = "linear.prediction")
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{print.merModList}{Print the results of a merMod list}{print.merModList}
%
\begin{Description}\relax
Print the results of a merMod list
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S3 method for class 'merModList'
print(x, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] a modList of class merModList

\item[\code{...}] additional arguments
\end{ldescription}
\end{Arguments}
%
\begin{Value}
summary content printed to console
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
sim_list <- replicate(n = 10,
        expr = sleepstudy[sample(row.names(sleepstudy), 180),],
        simplify=FALSE)
fml <- "Reaction ~ Days + (Days | Subject)"
mod <- lmerModList(fml, data = sim_list)
print(mod)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{print.summary.merModList}{Print the summary of a merMod list}{print.summary.merModList}
%
\begin{Description}\relax
Print the summary of a merMod list
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S3 method for class 'summary.merModList'
print(x, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] a summary of amerModList object

\item[\code{...}] additional arguments
\end{ldescription}
\end{Arguments}
%
\begin{Value}
summary content printed to console
\end{Value}
\inputencoding{utf8}
\HeaderA{randomObs}{Select a random observation from model data}{randomObs}
%
\begin{Description}\relax
Select a random observation from the model frame of a merMod
\end{Description}
%
\begin{Usage}
\begin{verbatim}
randomObs(merMod, varList, seed = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{merMod}] an object of class merMod

\item[\code{varList}] optional, a named list of conditions to subset the data on

\item[\code{seed}] numeric, optional argument to set seed for simulations
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Each factor variable in the data frame has all factor levels from the
full model.frame stored so that the new data is compatible with predict.merMod
\end{Details}
%
\begin{Value}
a data frame with a single row for a random observation, but with full
factor levels. See details for more.
\end{Value}
\inputencoding{utf8}
\HeaderA{ranef.merModList}{Extract random-effects estimates for a merModList}{ranef.merModList}
%
\begin{Description}\relax
Extract random-effects estimates for a merModList
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S3 method for class 'merModList'
ranef(object, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] an object of a class of fitted models with
random effects, typically a
\code{\LinkA{merMod}{merMod.Rdash.class}} object.

\item[\code{...}] some methods for these generic functions
require additional arguments.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Extract the estimates of the random-effects parameters from a list of
fitted \code{merMod} models. Takes the mean of the individual \code{ranef}
objects for each of the component models in the \code{merModList}.
\end{Details}
%
\begin{Value}
a named, numeric vector of random-effects estimates.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
sim_list <- replicate(n = 10,
        expr = sleepstudy[sample(row.names(sleepstudy), 180),],
        simplify=FALSE)
fml <- "Reaction ~ Days + (Days | Subject)"
mod <- lmerModList(fml, data = sim_list)
ranef(mod)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{REcorrExtract}{Extract the correlations between the slopes and the intercepts from a model}{REcorrExtract}
%
\begin{Description}\relax
Extract the correlations between the slopes and the intercepts from a model
\end{Description}
%
\begin{Usage}
\begin{verbatim}
REcorrExtract(model)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{model}] an object that inherits from class merMod
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a numeric vector of the correlations among the effects
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
fm1 <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
REcorrExtract(fm1)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{REextract}{Extracts random effects}{REextract}
%
\begin{Description}\relax
Extracts random effect terms from an lme4 model
\end{Description}
%
\begin{Usage}
\begin{verbatim}
REextract(merMod)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{merMod}] a merMod object from the lme4 package
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a data frame with the following columns
\begin{description}

\item[groupFctr] The name of the grouping factor associated with the random effects
\item[groupID] The level of the grouping factor associated with the random effects
\item['term'] One column per random effect, the name is derived from the merMod
\item['term'\_se] One column per random effect, the name is derived from the merMod

\end{description}

\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
require(lme4)
m2 <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
rfx <- REextract(m2)
#Note the column names
head(rfx)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{REimpact}{Calculate the weighted mean of fitted values for various levels of random effect terms.}{REimpact}
%
\begin{Description}\relax
\code{REimpact} calculates the average predicted value for each row of a
new data frame across the distribution of \code{\LinkA{expectedRank}{expectedRank}} for a
merMod object. This allows the user to make meaningful comparisons about the
influence of random effect terms on the scale of the response variable,
for user-defined inputs, and accounting for the variability in grouping terms.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
REimpact(merMod, newdata, groupFctr = NULL, term = NULL, breaks = 3, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{merMod}] An object of class merMod

\item[\code{newdata}] a data frame of observations to calculate group-level differences
for

\item[\code{groupFctr}] The name of the grouping factor over which the random
coefficient of interest varies.  This is the variable to the right of the
pipe, \code{|}, in the [g]lmer formula. This parameter is optional, if not
specified, it will perform the calculation for the first effect listed
by \code{ranef}.

\item[\code{term}] The name of the random coefficient of interest. This is the
variable to the left of the pipe, \code{|}, in the [g]lmer formula. Partial
matching is attempted on the intercept term so the following character
strings will all return rankings based on the intercept (\emph{provided that
they do not match the name of another random coefficient for that factor}):
\code{c("(Intercept)", "Int", "intercep", ...)}.

\item[\code{breaks}] an integer representing the number of bins to divide the group
effects into, the default is 3; alternatively it can specify breaks from 0-100
for how to cut the expected rank distribution

\item[\code{...}] additional arguments to pass to \code{\LinkA{predictInterval}{predictInterval}}
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The function predicts the response at every level in the random effect term
specified by the user. Then, the expected rank of each group level is binned
to the number of bins specified by the user. Finally, a weighted mean of the
fitted value for all observations in each bin of the expected ranks is
calculated using the inverse of the variance as the weight -- so that less
precise estimates are downweighted in the calculation of the mean for the bin.
Finally, a standard error for the bin mean is calculated.

This function uses the formula for variance of a weighted mean
recommended by Cochran (1977).
\end{Details}
%
\begin{Value}
A data.frame with all unique combinations of the number of cases, rows
in the newdata element, and number of bins:
\begin{description}

\item[case] The row number of the observation from newdata.
\item[bin] The ranking bin for the expected rank, the higher the bin number,
the greater the expected rank of the groups in that bin.
\item[AvgFitWght] The weighted mean of the fitted values for case i in bin k
\item[AvgFitWghtSE] The standard deviation of the mean of the fitted values
for case i in bin k.
\item[nobs] The number of group effects contained in that bin.

\end{description}

\end{Value}
%
\begin{References}\relax
Gatz, DF and Smith, L. The Standard Error of a Weighted Mean Concentration.
I. Bootstrapping vs other methods. \emph{Atmospheric Environment}.
1995;11(2)1185-1193. Available at
\url{http://www.sciencedirect.com/science/article/pii/135223109400210C}

Cochran, WG. 1977. Sampling Techniques (3rd Edition). Wiley, New York.
\end{References}
%
\begin{SeeAlso}\relax
\code{\LinkA{expectedRank}{expectedRank}}, \code{\LinkA{predictInterval}{predictInterval}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
#For a one-level random intercept model
require(lme4)
m1 <- lmer(Reaction ~ Days + (1 | Subject), sleepstudy)
(m1.er <- REimpact(m1, newdata = sleepstudy[1, ], breaks = 2))

#For a one-level random intercept model with multiple random terms
m2 <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
#ranked by the random slope on Days
(m2.er1 <- REimpact(m2,  newdata = sleepstudy[1, ],
           groupFctr = "Subject", term="Days"))
#ranked by the random intercept
(m2.er2 <- REimpact(m2, newdata = sleepstudy[1, ],
             groupFctr = "Subject", term="int"))
## Not run: 
# You can also pass additional arguments to predictInterval through REimpact
g1 <- lmer(y ~ lectage + studage + (1|d) + (1|s), data=InstEval)
zed <- REimpact(g1, newdata = InstEval[9:12, ], groupFctr = "d", n.sims = 50,
                include.resid.var = TRUE)
zed2 <- REimpact(g1, newdata = InstEval[9:12, ], groupFctr = "s", n.sims = 50,
                 include.resid.var = TRUE)
zed3 <- REimpact(g1, newdata = InstEval[9:12, ], groupFctr = "d", breaks = 5,

## End(Not run)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{REquantile}{Identify group level associated with RE quantile}{REquantile}
%
\begin{Description}\relax
For a user specified quantile (or quantiles) of the random effect
terms in a merMod object. This allows the user to easily identify the observation
associated with the nth percentile effect.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
REquantile(merMod, quantile, groupFctr, term = "(Intercept)")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{merMod}] a merMod object with one or more random effect levels

\item[\code{quantile}] a numeric vector with values between 0 and 100 for quantiles

\item[\code{groupFctr}] a character of the name of the random effect grouping factor to extract
quantiles from

\item[\code{term}] a character of the random effect to extract for the grouping factor
specified. Default is the intercept.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a vector of the level of the random effect grouping term that corresponds
to each quantile
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
fm1 <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
REquantile(fm1, quantile = 0.25, groupFctr = "Subject")
REquantile(fm1, quantile = 0.25, groupFctr = "Subject", term = "Days")
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{REsdExtract}{Extract the standard deviation of the random effects from a merMod object}{REsdExtract}
%
\begin{Description}\relax
Extract the standard deviation of the random effects from a merMod object
\end{Description}
%
\begin{Usage}
\begin{verbatim}
REsdExtract(model)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{model}] an object that inherits from class merMod
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a numeric vector for standard deviations of the random effects
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
fm1 <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
REsdExtract(fm1)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{REsim}{Simulate random effects from merMod \code{REsim} simulates random effects from merMod object posterior distributions}{REsim}
%
\begin{Description}\relax
Simulate random effects from merMod
\code{REsim} simulates random effects from merMod object posterior distributions
\end{Description}
%
\begin{Usage}
\begin{verbatim}
REsim(merMod, n.sims = 200, oddsRatio = FALSE, seed = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{merMod}] a merMod object from the lme4 package

\item[\code{n.sims}] number of simulations to use

\item[\code{oddsRatio}] logical, should parameters be converted to odds ratios?

\item[\code{seed}] numeric, optional argument to set seed for simulations
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Use the Gelman sim technique to build empirical Bayes estimates.
Uses the sim function in the arm package
\end{Details}
%
\begin{Value}
a data frame with the following columns
\begin{description}

\item[\code{groupFctr}] Name of the grouping factor
\item[\code{groupID}] Level of the grouping factor
\item[\code{term}] Name of random term (intercept/coefficient)
\item[\code{mean}] Mean of the simulations
\item[\code{median}] Median of the simulations
\item[\code{sd}] Standard deviation of the simulations, \code{NA} if \code{oddsRatio=TRUE}

\end{description}

\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
require(lme4)
m2 <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
re2 <- REsim(m2, 25)
head(re2)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{RMSE.merMod}{Estimate the Root Mean Squared Error (RMSE) for a lmerMod}{RMSE.merMod}
%
\begin{Description}\relax
Extract the Root Mean Squared Error for a lmerMod object
\end{Description}
%
\begin{Usage}
\begin{verbatim}
RMSE.merMod(merMod, scale = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{merMod}] a lmerMod object from the lme4 package

\item[\code{scale}] logical, should the result be returned on the scale of
response variable standard deviations?
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a numeric which represents the RMSE
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
require(lme4)
m2 <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
RMSE.merMod(m2)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{sanitizeNames}{Clean up variable names in data frames}{sanitizeNames}
%
\begin{Description}\relax
Strips out transformations from variable names in data frames
\end{Description}
%
\begin{Usage}
\begin{verbatim}
sanitizeNames(data)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{data}] a data.frame
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a data frame with variable names cleaned to remove factor() construction
\end{Value}
\inputencoding{utf8}
\HeaderA{setup\_parallel}{Set up parallel environment}{setup.Rul.parallel}
%
\begin{Description}\relax
Set up parallel environment
\end{Description}
%
\begin{Usage}
\begin{verbatim}
setup_parallel()
\end{verbatim}
\end{Usage}
%
\begin{Value}
Nothing
\end{Value}
\inputencoding{utf8}
\HeaderA{shinyMer}{Launch a shiny app to explore your merMod interactively}{shinyMer}
%
\begin{Description}\relax
\code{shinyMer} launches a shiny app that allows you to interactively
explore an estimated merMod using functions from \code{merTools}.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
shinyMer(merMod, simData = NULL, pos = 1)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{merMod}] An object of class "merMod".

\item[\code{simData}] A data.frame to make predictions from (optional). If
NULL, then the user can only make predictions using the data in
the frame slot of the merMod object.

\item[\code{pos}] The position of the environment to export function arguments to.
Defaults to 1, the global environment, to allow shiny to run.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A shiny app
\end{Value}
\inputencoding{utf8}
\HeaderA{shuffle}{Randomly reorder a dataframe}{shuffle}
%
\begin{Description}\relax
Randomly reorder a dataframe by row
\end{Description}
%
\begin{Usage}
\begin{verbatim}
shuffle(data)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{data}] a data frame
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a data frame of the same dimensions with the rows reordered
randomly
\end{Value}
\inputencoding{utf8}
\HeaderA{stripAttributes}{Remove attributes from a data.frame}{stripAttributes}
%
\begin{Description}\relax
Strips attributes off of a data frame that come with a merMod model.frame
\end{Description}
%
\begin{Usage}
\begin{verbatim}
stripAttributes(data)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{data}] a data.frame
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a data frame with variable names cleaned to remove all attributes except for
names, row.names, and class
\end{Value}
\inputencoding{utf8}
\HeaderA{subBoot}{Bootstrap a subset of an lme4 model}{subBoot}
%
\begin{Description}\relax
Bootstrap a subset of an lme4 model
\end{Description}
%
\begin{Usage}
\begin{verbatim}
subBoot(merMod, n = NULL, FUN, R = 100, seed = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{merMod}] a valid merMod object

\item[\code{n}] the number of rows to sample from the original data
in the merMod object, by default will resample the entire model frame

\item[\code{FUN}] the function to apply to each bootstrapped model

\item[\code{R}] the number of bootstrap replicates, default is 100

\item[\code{seed}] numeric, optional argument to set seed for simulations
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
This function allows users to estimate parameters of a
large merMod object using bootstraps on a subset of the data.
\end{Details}
%
\begin{Value}
a data.frame of parameters extracted from each of the R replications.
The original values are appended to the top of the matrix.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
(fm1 <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy))
resultMatrix <- subBoot(fm1, n = 160, FUN = thetaExtract, R = 20)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{subsetList}{Subset a data.frame using a list of conditions}{subsetList}
%
\begin{Description}\relax
Split a data.frame by elements in a list
\end{Description}
%
\begin{Usage}
\begin{verbatim}
subsetList(data, list)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{data}] a data.frame

\item[\code{list}] a named list of splitting conditions
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a data frame with values that match the conditions in the list
\end{Value}
\inputencoding{utf8}
\HeaderA{sum.mm}{Title}{sum.mm}
%
\begin{Description}\relax
Title
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S3 method for class 'mm'
sum(object, correlation = (p <=
  getOption("lme4.summary.cor.max")), use.hessian = NULL, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] a merMod object

\item[\code{correlation}] optional p value

\item[\code{use.hessian}] logical

\item[\code{...}] additional arguments to pass through
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a summary of the object
\end{Value}
\inputencoding{utf8}
\HeaderA{summary.merModList}{Summarize a merMod list}{summary.merModList}
%
\begin{Description}\relax
Summarize a merMod list
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S3 method for class 'merModList'
summary(object, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] a modList of class merModList

\item[\code{...}] additional arguments
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a summary object of model information
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
sim_list <- replicate(n = 10,
        expr = sleepstudy[sample(row.names(sleepstudy), 180),],
        simplify=FALSE)
fml <- "Reaction ~ Days + (Days | Subject)"
mod <- lmerModList(fml, data = sim_list)
summary(mod)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{superFactor}{Create a factor with unobserved levels}{superFactor}
%
\begin{Description}\relax
Create a factor variable and include unobserved levels
for compatibility with model prediction functions
\end{Description}
%
\begin{Usage}
\begin{verbatim}
superFactor(x, fullLev)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] a vector to be converted to a factor

\item[\code{fullLev}] a vector of factor levels to be assigned to x
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a factor variable with all observed levels of x and all levels
of x in fullLev
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
regularFactor <- c("A", "B", "C")
regularFactor <- factor(regularFactor)
levels(regularFactor)
# Now make it super
newLevs <- c("D", "E", "F")
regularFactor <- superFactor(regularFactor, fullLev = newLevs)
levels(regularFactor) # now super
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{thetaExtract}{Extract theta parameters from a merMod model}{thetaExtract}
%
\begin{Description}\relax
A convenience function that returns the theta parameters for a
\code{\LinkA{merMod}{merMod}} object.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
thetaExtract(merMod)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{merMod}] a valid merMod object
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a vector of the covariance, theta, parameters from a \code{\LinkA{merMod}{merMod}}
\end{Value}
%
\begin{SeeAlso}\relax
merMod
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
(fm1 <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy))
thetaExtract(fm1) #(a numeric vector of the covariance parameters)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{VarCorr.merModList}{Extract the variances and correlations for random effects from a merMod list}{VarCorr.merModList}
%
\begin{Description}\relax
Extract the variances and correlations for random effects from a merMod list
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S3 method for class 'merModList'
VarCorr(x, sigma = 1, rdig = 3L)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] for \code{VarCorr}: a fitted model object, usually an object inheriting from
class \code{\LinkA{merMod}{merMod.Rdash.class}}. For \code{as.data.frame}, a
\code{VarCorr.merMod} object returned from \code{VarCorr}.

\item[\code{sigma}] an optional numeric value used as a multiplier for the
standard deviations.

\item[\code{rdig}] the number of digits to round to, integer
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a list with two elements "stddev" and "correlation" for the standard
deviations and correlations averaged across models in the list
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
sim_list <- replicate(n = 10,
        expr = sleepstudy[sample(row.names(sleepstudy), 180),],
        simplify=FALSE)
fml <- "Reaction ~ Days + (Days | Subject)"
mod <- lmerModList(fml, data = sim_list)
VarCorr(mod)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{wiggle}{Assign an observation to different values}{wiggle}
%
\begin{Description}\relax
Creates a new data.frame with copies of the original observation,
each assigned to a different user-specified value of a variable. Allows the
user to look at the effect on predicted values of changing either a single variable
or multiple variables.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
wiggle(data, varlist, valueslist)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{data}] a data frame with one or more observations to be reassigned

\item[\code{varlist}] a character vector specifying the name(s) of the variable to adjust

\item[\code{valueslist}] a list of vectors with the values to assign to var
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
If the variable specified is a factor, then wiggle will return it
as a character.
\end{Details}
%
\begin{Value}
a \code{data.frame} with each row assigned to the one of the new variable combinations.
All variable combinations are returned, eg wiggling two variables with 3 and 4 variables
respectively will return a new dataset with \code{3 * 4 = 12} observations.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
data(iris)
wiggle(iris[3,], varlist = "Sepal.Width", valueslist = list(c(1, 2, 3, 5)))
wiggle(iris[3:5,], "Sepal.Width", valueslist = list(c(1, 2, 3, 5)))
wiggle(iris[3,], c("Sepal.Width", "Petal.Length"), list(c(1,2,3,5), c(3,5,6)))
wiggle(iris[3:5,], c("Sepal.Width", "Petal.Length"), list(c(1,2,3,5), c(3,5,6)))
\end{ExampleCode}
\end{Examples}
\printindex{}
\end{document}
