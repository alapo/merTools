---
title: "Using `predictInterval()`"
author: "Jared Knowles and Carl Frederick"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using_predictInterval}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, echo = FALSE}
knitr::opts_chunk$set(
  cache=TRUE,
  comment="#>",
  collapse=TRUE
)
library(abind); library(mvtnorm); library(knitr);
source("F:/RSandbox/merTools/R/merPredict.R")
```

Fitting (generalized) linear mixed models, (G)LMM, to very large data sets is becomming increasingly easy, but understanding and
communicating the uncertainty inherent in those models is not. As the documentation for `lme4::predict.merMod()` notes:

>There is no option for computing standard errors of predictions because it is difficult to define an efficient method that >incorporates uncertainty in the variance parameters; we recommend `lme4::bootMer()` for this task.

We agree that, short of a fully bayesian analysis, bootstrapping is the gold-standard for deriving a prediction interval 
predictions from a (G)LMM, but the time required to obtain even a respectable number of replications quickly becomes prohibitive when the initial model fit is on the order of hours instead of seconds. The only(?) other alternative out there is to use the `arm::sim()` function to simulate values, but this only takes variation of the fixed coefficients and residuals into account. 

We developed this function to incorporate the variation in the conditional modes of the random effects (CMRE, a.k.a. BLUPs in the LMM case) into calculating prediction intervals. We take the warning from `lme4::predict.merMod()` seriously, but view this method as a decent first approximation the full bootstrap analysis for (G)LMMs fit to very large data sets.

*...we could add some stuff here about consequential decisions being made about the fitted random effects estimates and the lack of availability of quick methods...*

## Conceptual description

There are three sources of uncertainty in mixed models:
  (1) the residual (observation-level) variance,
  (2) the uncertainty in the fixed coefficients, and
  (3) the uncertainty in the variance parameters for the grouping factors.
As we mentioned above, the `arm:sim()` function incorporates the first two sources of variation but not the third and bootstrapping methods using `lme4::bootMer()` does incorporate all three sources of uncertainty because it re-estimates the model using random samples of the data.

When inference about the values of the CMREs is of interest, it would be nice to incorporate some degree of uncertainty in 
those estimates when comparing observations across groups. `predictInterval()` does this by drawing values of the CMREs from 
the conditional variance-covariance matrix of the random affects accessible from `arm::ranef(model, condVar=TRUE)`. Thus, `predictInterval()` incorporates all of the uncertainty from sources one and two, and part of the variance from source 3, but the variance parameters themselves are treated as fixed.

Essentially, `predictInterval()` takes an estimated model of class "merMod" and, like `predict()`, a data.frame upon which
to make those predictions and:
  - *First*  extracts the fixed and random coefficients
  - *Second* takes `nsims` draws from the multivariate normal distribution of the fixed and random coefficients (separately)
  - *Third*  calculates the linear predictor for each row in `newdata` based on these draws and
  - *Fourth* either incorporates the residual variation (per the `arm::sim()` function) or, if specified by the user, not
  - *Fifth*  returns newdata with the lower and upper limits of the prediction interval and the mean or median of the simulated              predictions

Currently, the supported model types are linear mixed models and mixed logistic regression models.  

The prediction data set *can* include levels that are not in the estimation model frame. The prediction intervals for such observations only incorporate uncertainty from fixed coefficient estimates and the residual level variation.

## Comparison to existing methods

What do the differences between `predictInterval()` and the other methods for constructing prediction intervals mean in practice?  This section compares the results of `predictInterval()` with those obtained using `arm::sim()` and `lme4::bootMer()` using the sleepstudy data from `lme4`.

###Step 1: Estimating the model and using `predictInterval()`

First, we will load the required packages and data and estimate the model:

```{r Prep, message=FALSE}
library(lme4); library(arm); 
##library(merTools);
set.seed(271828)
data(sleepstudy)
fm1 <- lmer(Reaction ~ Days + (Days|Subject), data=sleepstudy)
display(fm1)
```

Then, calculate prediction intervals using `predictInterval()`.  For this example we will calculate the prediction interval for the original data.frame.

```{r predInt}
PI.time <- system.time(
  PI <- predictInterval(model = fm1, newdata = sleepstudy, 
                        level = 0.95, nsim = 1000,
                        stat = "median", predict.type="linear.prediction",
                        include.resid.var = TRUE)
)
```

Here is the first few rows of the object `PI`:
```{r Inspect predInt, results="asis", echo=FALSE}
kable(head(PI))
```

The final three columns are the median (`fit`) and limits of the 95% prediction interval (`upr` and `lwr`). The following figure displays the output graphically for the first 20 observations.

```{r Inspect predInt 2, fig.width=7, fig.align="center"}
library(ggplot2);
ggplot(aes(x=1:20, y=fit, ymin=lwr, ymax=upr), data=PI[1:20,]) +
  geom_point() + 
  geom_linerange() +
  labs(x="Index", y="Prediction w/ 95% PI")
```

###Step 2: ... vs `arm::sim()`

This section will compare the output above to those we could get from `arm::sim()`.

```{r arm.Sim, fig.width=7, fig.align="center"}
PI.arm.time <- system.time(
  PI.arm.sims <- arm::sim(fm1, 1000)
)

PI.arm <- data.frame(
  fit=apply(fitted(PI.arm.sims, fm1), 1, function(x) quantile(x, 0.500)),
  upr=apply(fitted(PI.arm.sims, fm1), 1, function(x) quantile(x, 0.975)),
  lwr=apply(fitted(PI.arm.sims, fm1), 1, function(x) quantile(x, 0.025))
)

comp.data <- rbind(data.frame(type="predictInterval()", x=(1:nrow(PI))-0.1, PI[,4:6]),
                   data.frame(type="arm::sim()", x=(1:nrow(PI.arm))+0.1, PI.arm))

ggplot(aes(x=x, y=fit, ymin=lwr, ymax=upr, color=type), data=comp.data[c(1:20,181:200),]) +
  geom_point() + 
  geom_linerange() +
  labs(x="Index", y="Prediction w/ 95% PI")
          
              
```


