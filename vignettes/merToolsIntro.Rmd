---
title: "An Introduction to merTools"
author: "Jared Knowles and Carl Frederick"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{An Introduction to merTools}
  %\VignetteEncoding{UTF-8}
---

```{r setup, echo = FALSE, message=FALSE, warning=FALSE, results='hide'}
knitr::opts_chunk$set(
  cache=TRUE,
  comment="#>",
  collapse=TRUE
)
library(knitr); library(merTools)
```

## Introduction

Working with generalized linear mixed models (GLMM) and linear mixed models (LMM) 
has become increasingly easy with the advances in the `lme4` package recently. 
As we have found ourselves using these models more and more within our work, we, 
the authors, have developed a set of tools for simplifying and speeding up common 
tasks for interacting with `merMod` objects from `lme4`. This package provides 
those tools. 

## Illustrating Model Effects

As the complexity of the model fit grows, it becomes harder and harder to 
interpret the substantive effect of parameters in the model. 

Let's start with a medium-sized example model using the `InstEval` data provided 
by the `lme4` package. These data represent university lecture evaluations at 
ETH Zurich made by students. In this data, `s` is an individual student, 
`d` is an individual lecturer, `studage` is the semester the student 
is enrolled, `lectage` is how many semesters back the lecture with the 
rating took place, `dept` is the department of the lecture, and `y` is an integer 
1:5 representing the ratings of the lcture from "poor" to "very good":

```{r}
library(lme4)
head(InstEval)
str(InstEval)
```

Starting with a simple model: 

```{r}
m1 <- lmer(y ~ service + lectage + studage + (1|d) + (1|s), data=InstEval)
```

After fitting the model we can make use of the first function provided by
`merTools`, `fastdisp` which modifies the function `arm:::display` to more 
quickly display a summary of the model without calculating the model sigma:

```{r}
library(merTools)
fastdisp(m1)
```

We see some interesting effects. First, our decision to include student and 
lecturer effects seems justified as there is substantial variance within these 
groups. Second, there do appear to be some effects by age and for lectures 
given as a service by an outside lecturer. Let's look at these in more detail. 
One way to do this would be to plot the coefficients together in a line to 
see which deviate from 0 and in what direction. To get a confidence interval 
for our fixed effect coefficients we have a number of options that represent a 
tradeoff between coverage and computation time -- see `confint.merMod` for 
details. 

An alternative is to simulate values of the fixed effects from the posterior 
using the function `arm::sim`. Our next tool, `FEsim`, is a convenience wrapper 
to do this and provide an informative data frame of the results. 

```{r}
feEx <- FEsim(m1, 1000)
cbind(feEx[,1] , round(feEx[, 2:4], 3))
```

We can present these results graphically, using `ggplot2`: 

```{r}
library(ggplot2)
ggplot(feEx[feEx$variable!= "(Intercept)", ]) + 
  aes(x = variable, ymin = median_eff - 1.96 * sd_eff, 
      ymax = median_eff + 1.96 * sd_eff, 
                   y = median_eff) + geom_pointrange() + 
  geom_hline(yintercept = 0, size = I(1.1), color = I("red")) + 
  coord_flip() + 
  theme_bw() + labs(title = "Coefficient Plot of InstEval Model", 
                    x = "Median Effect Estimate", y = "Evaluation Rating")
```

However, an easier option is:

```{r}
plotFEsim(feEx) + 
  theme_bw() + labs(title = "Coefficient Plot of InstEval Model", 
                    x = "Median Effect Estimate", y = "Evaluation Rating")

```


Next, we might be interested in exploring the random effects. Again, we create a 
dataframe of the values of the simulation of these effects for the individual 
levels. 

```{r}
reEx <- REsim(m1)
head(reEx)
```

The result is a dataframe with estimates of the values of each of the random 
effects provided by the `arm::sim()` function. Group represents the identfiable 
level for the variable for one random effect, effect represents whether the 
simulated values are for an intercept or which slope, and level identifies 
which of the `(1|x)` terms the values represent. To make unique identifiers 
for each effect, we need to use both the `group` and the `level` term in case 
these two variables use overlapping label names for their groups. In this case:

```{r}
table(reEx$effect)
table(reEx$level)
```

Most important is producing caterpillar or dotplots of these terms to explore 
their variation. This is easily accomplished:

```{r}
lattice::dotplot(ranef(m1, condVar=TRUE))
```

However, these graphics do not provide much control over the results. Instead, 
we can use the `plotREsim` function in `merTools` to gain more control over 
plotting of the random effect simulations. 

```{r}
p1 <- plotREsim(reEx)
p1
```

The result is a ggplot2 object which can be modified however the user sees 
fit. Here, we've established that most student and professor effects are 
indistinguishable from zero, but there do exist extreme outliers with both 
high and low averages that need to be accounted for. 

A logical next line of questioning is to see how much of the variation in a 
rating can be caused by changing the student rater and how much is due to the 
fixed effects we identified above. This is a very difficult problem to solve, 
but using simulation we can examine the model behavior under a range of scenarios 
to understand how the model is reflecting changes in the data. To do this, 
we use another set of functions available in `merTools`. 

The simplest option is to pick an observation at random and then modify its 
values deliberately to see how the prediction changes in response. `merTools` 
makes this task very simple:

```{r}
example1 <- randomObs(m1)
head(example1)
```

The `randomObs` function takes a random observation from the data in the model 
and extracts it as a dataframe. We can now do a number of operations to this 
observation:

```{r}
# predict it
predict(m1, newdata = example1)
# change values
example1$service <- "1"
predict(m1, newdata = example1)
```



